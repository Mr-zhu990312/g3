# g3

项目整体 UI 组件库：

https://github.com/youzan/vant-weapp[Vant]

可供选择的 Icon 库：

https://www.iconfont.cn[阿里巴巴矢量图标]

https://material.io/tools/icons[Material Design Icon]

https://ikonate.com/#content[Ikonate]

页面设计参考：

https://dribbble.com[Dribbble]


底部 Tabbar 暂定分成 3 个入口。

大致的页面组成为：

. 首页
. 肤质测试页
. 整体分类页
. 商品详情页
. 购物车页
. 结算页面
. 我的

=== 陈鑫文档
1，	day2实训基本内容：

A，	第一天构建主要的tab控件、分类控 件，设计基本的色调及展示理念，能够 在设计文档中进行整理； 

a:目标分析



b:步骤

c:相关参考资料

B，	在小程序中调用各类手机传感器，本实例中调用光学摄像头；

a:目标分析

b:步骤

c:相关参考资料
 
C，学习在小程序界面中对历史数据进行 存储。小组长能够设计一个第三方后台 的远程程序（基于websocket），对组员 的小程序数据库进行远程管理； 

a:目标分析

b:步骤

c:相关参考资料

2，	实训高级内容： 

A，	对所存储的基本图像，进行光学校正 ，具体指增加/减少曝光度、白平衡等；

a:目标分析

基于opencv的图像的白平衡处理机制，用来解决客户在环境不太友好的情况下，最大可能的还原真实的脸部特征和肤色。 在参考以下资料以后，我采用了“完美世界反射和灰度世界假设法”来进行图像的白平衡修正。

b:步骤

1.算法原理

灰度世界算法假定图片具有大量的色彩变化，于是RGB分量趋近于同一个值K。一般令 K = (Raver+Gaver+Baver)/3,其中Raver,Gaver,Baver分别表示红、 绿、 蓝三个通道的平均值。第二步是计算各通道的增益，如Kr=K/Raver，最后图像中每一个像素点Rnew = R * Kr。意思大概就是如果某个通道平均强度大于三通道的平均强度，就令这个通道的整体强度按比例降低，反之亦然。

另一个算法完美反射算法假设图片中最亮的点就是一面镜子，完美地反射了外部光照，并根据这些白点进行白平衡。它定义为R+G+B的最大值。让这些白点的RGB三个通道按照比例拉伸到255，并将其他的点的三个通道按照同样比例拉伸，超过255的设为255，是一个归一化过程。opencv中的完美反射大概是将白点的比例设为1%，改了个名字叫simpleWB，这样用户就不用调参数了。

2.算法实现：

首先:引用opencv、matplotlib和numpy模块

1.由于图像处理矩阵对传入的图片的大小和像素的多少在进行处理的时候会导致时间的长短不一样。由于我们这个在用户上传图像以后会要求马上出结果，所以先要进行一个图像的大小设置和压缩。在这里我把图片设置成了（300,480）的规格大小。

res = cv2.imread(r'images\4.jpg')
img=cv2.resize(res,(300,480),interpolation=cv2.INTER_CUBIC)

2.核心代码

    m, n, t = img.shape
    print(b.shape)
    sum = np.zeros(b.shape)
    for i in range(m):
        for j in range(n):
            sum[i][j] = int(b[i][j]) + int(g[i][j]) + int(r[i][j])
    hists, bins = np.histogram(sum.flatten(), 766, [0, 766])
    Y = 765
    num, key = 0, 0
    while Y >= 0:
        num += hists[Y]
        if num > m * n * 0.01 / 100:
            key = Y
            break
        Y = Y - 1

    sum_b, sum_g, sum_r = 0, 0, 0
    time = 0
    for i in range(m):
        for j in range(n):
            if sum[i][j] >= Y:
                sum_b += b[i][j]
                sum_g += g[i][j]
                sum_r += r[i][j]
                time = time + 1

    avg_b = sum_b / time
    avg_g = sum_g / time
    avg_r = sum_r / time

    for i in range(m):
        for j in range(n):
            b[i][j] = b[i][j] * 255 / avg_b
            g[i][j] = g[i][j] * 255 / avg_g
            r[i][j] = r[i][j] * 255 / avg_r
            if b[i][j] > 255:
                b[i][j] = 255
            if b[i][j] < 0:
                b[i][j] = 0
            if g[i][j] > 255:
                g[i][j] = 255
            if g[i][j] < 0:
                g[i][j] = 0
            if r[i][j] > 255:
                r[i][j] = 255
            if r[i][j] < 0:
                r[i][j] = 0

    img_0 = cv2.merge([b, g, r])
    cv2.imshow('xiutu', img_0)

实验结果：




c:相关参考资料

https://blog.csdn.net/shadow_guo/article/details/43602051 肤色检测
https://patents.google.com/patent/CN106529429A/zh 肤质检测硕博论文

B，调用手机角度传感器，并且计算人脸 的轮廓，提示用户脸型是否摆正，距离 是否合适；

a:目标分析

b:步骤

c:相关参考资料

C，能够调用控件，完成对不同产品类（ SKU）相关图片的展示；（点击品牌、热 门、新品等按键）

a:目标分析

b:步骤

c:相关参考资料
